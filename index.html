<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE MENU - UNIVERSAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #e0e0e0;
            font-family: 'VT323', 'Courier New', Courier, monospace;
            overflow: hidden;
            /* 允许鼠标操作 */
            touch-action: none; 
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer; /* 电脑上显示手型光标 */
        }

        /* 旋转的背景层 */
        #bg-layer {
            position: fixed;
            top: -50%; left: -50%; width: 200%; height: 200%;
            z-index: 1;
            /* 同时尝试加载 png 和 jpg，哪个有显示哪个 */
            background-image: url('./cd_bg.png'), url('./cd_bg.jpg');
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.5);
            opacity: 1;
            animation: rotateBG 60s linear infinite;
        }

        @keyframes rotateBG {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        #gameCanvas {
            position: relative;
            z-index: 5;
            image-rendering: pixelated; 
            max-width: 100%;
            max-height: 100%;
        }

        .ui-text {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
        }

        #top-ui {
            top: 10%;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        #score-box {
            border: 2px solid #fff;
            padding: 5px 20px;
            background: rgba(0,0,0,0.7);
            font-size: 28px;
            color: #4DFF4D;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(77,255,77,0.5);
            font-family: 'VT323', monospace;
        }

        #footer-ui {
            bottom: 20%;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 14px;
            z-index: 20;
            font-family: 'VT323', monospace;
            opacity: 0.7;
            animation: pulseText 2s infinite;
        }

        @keyframes pulseText {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }

        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }
        
        #title-container {
            position: absolute;
            bottom: 5%;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #menu-subtitle {
            font-size: 18px;
            color: #fff;
            background-color: #4D8FFF;
            display: inline-block;
            padding: 4px 12px;
            margin-bottom: 8px;
            font-weight: bold;
            transform: skew(-10deg);
            white-space: nowrap;
            max-width: 85%;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: 0 0 10px rgba(77, 143, 255, 0.5);
        }

        #menu-title {
            font-size: 48px;
            font-weight: bold;
            color: #4D8FFF;
            text-shadow: 0 0 15px rgba(77,143,255,0.8);
            letter-spacing: 5px;
            font-family: 'VT323', monospace;
            line-height: 1;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.15) 50%, rgba(0,0,0,0.15));
            background-size: 100% 3px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>

    <div id="bg-layer"></div>

    <div id="start-screen">
        <h1 style="font-size:40px; color:#4DFF4D; margin-bottom:10px;">THE MENU</h1>
        <p style="font-size:16px; color:#aaa;">PC & MOBILE COMPATIBLE</p>
        <p class="blink" style="font-size:24px; color:#fff; margin-top:20px;">[ CLICK / TAP TO START ]</p>
    </div>

    <div id="top-ui" class="ui-text">
        <div id="score-box">SCORE: <span id="scoreVal" style="color:#4DFF4D">00000</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="footer-ui" class="ui-text">
        CLICK OR TAP TO SWITCH
    </div>

    <div id="title-container">
        <div id="menu-subtitle">01. おうち (EAINT THAN THAR)</div>
        <div id="menu-title">THE MENU</div>
    </div>

    <div class="scanlines"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreVal');
        const startScreen = document.getElementById('start-screen');
        const subtitleEl = document.getElementById('menu-subtitle');
        
        let config = {
            laneCount: 6,
            baseRadius: 0,
            laneGap: 0,
            rotationSpeed: 0.003,
            playerAngle: Math.PI / 2,
            colors: ['#FF4D4D', '#FF9F4D', '#FFE04D', '#4DFF4D', '#4DFFFF', '#9F4DFF'],
            dishNames: [
                "01. おうち (EAINT THAN THAR)",
                "02. 糸 (LI JIAYU)",
                "03. 二畳 (SUN JIAHAO)",
                "04. 花園 (TIAN ZHIYUAN)",
                "05. MYSPACE (WANG JIEWEI)",
                "06. LOAM (XU JIAYANG)"
            ]
        };

        let state = {
            isPlaying: false,
            currentLane: 0,
            score: 0,
            foods: [],
            gameTime: 0,
            bgRotation: 0,
            ripples: []
        };

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let analyser; 
        let dataArray; 
        let bgmInterval;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 64; 
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.connect(audioCtx.destination);
            startBGM();
        }

        // 安全的震动函数
        function vibratePhone(ms) {
            try {
                if (navigator.vibrate) {
                    navigator.vibrate(ms);
                }
            } catch(e) {
                // 电脑不支持震动，忽略错误
            }
        }

        function playScoreSound() {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(analyser); 
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function startBGM() {
            if(!audioCtx || bgmInterval) return;
            const sequence = [
                220, 0, 261, 0, 
                329, 0, 293, 0, 
                196, 0, 220, 0,
                392, 0, 329, 0
            ];
            let noteIndex = 0;

            bgmInterval = setInterval(() => {
                if(!state.isPlaying) return;
                
                const freq = sequence[noteIndex];
                noteIndex = (noteIndex + 1) % sequence.length;
                
                if (freq > 0) {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.08, audioCtx.currentTime); 
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.connect(gain);
                    gain.connect(analyser);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                }
                
                if (noteIndex % 4 === 0) {
                    const kick = audioCtx.createOscillator();
                    const kickGain = audioCtx.createGain();
                    kick.type = 'sine';
                    kick.frequency.setValueAtTime(150, audioCtx.currentTime);
                    kick.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    kickGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    kickGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    kick.connect(kickGain);
                    kickGain.connect(analyser);
                    kick.start();
                    kick.stop(audioCtx.currentTime + 0.5);
                }
            }, 250);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const minDim = Math.min(canvas.width, canvas.height);
            // 电脑屏幕通常更大，这里做个适配
            const maxVisibleRadius = (minDim * 0.35);
            config.laneGap = maxVisibleRadius / (config.laneCount + 1);
            config.baseRadius = config.laneGap * 1.5;
        }
        window.addEventListener('resize', resize);
        resize();

        const fruitDesigns = [
            { map: ["  2 2  ", "  111  ", " 11111 ", " 11111 ", "  111  ", "   1   "], leafColor: '#00FF00' }, 
            { map: ["  222  ", " 11111 ", "1111111", "1111111", " 11111 ", "  111  "], leafColor: '#00AA00' }, 
            { map: ["   1   ", "  111  ", " 11111 ", " 11111 ", "  111  ", "   1   "], leafColor: '#FFFFFF' }, 
            { map: ["   2   ", "  212  ", " 11111 ", " 11111 ", " 11111 ", "  111  "], leafColor: '#654321' }, 
            { map: ["       ", " 11 11 ", " 11 11 ", "       ", "  111  ", "  111  "], leafColor: '#fff' },    
            { map: [" 22222 ", "  111  ", " 11111 ", "  111  ", "   1   ", "       "], leafColor: '#00FF00' }  
        ];
        
        const fruitSprites = fruitDesigns.map((d, i) => {
            const sizeX = d.map[0].length;
            const sizeY = d.map.length;
            const scale = 3;
            const c = document.createElement('canvas');
            c.width = sizeX * scale; 
            c.height = sizeY * scale;
            const xCtx = c.getContext('2d');
            d.map.forEach((row, y) => {
                row.split('').forEach((char, x) => {
                    if (char === '1') { xCtx.fillStyle = config.colors[i]; xCtx.fillRect(x * scale, y * scale, scale, scale); } 
                    else if (char === '2') { xCtx.fillStyle = d.leafColor; xCtx.fillRect(x * scale, y * scale, scale, scale); }
                });
            });
            return c;
        });

        class Player {
            draw() {
                const r = config.baseRadius + (state.currentLane + 0.5) * config.laneGap;
                const x = canvas.width / 2 + Math.cos(config.playerAngle) * r;
                const y = canvas.height / 2 + Math.sin(config.playerAngle) * r;
                
                ctx.save();
                const size = 20;
                ctx.fillStyle = '#fff';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 5;
                ctx.fillRect(x - size/2, y - size/2, size, size);
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#000';
                const eyeSize = 4; 
                ctx.translate(x, y);
                ctx.rotate(config.playerAngle + Math.PI/2); 
                ctx.fillRect(-5, -4, eyeSize, eyeSize);
                ctx.fillRect(1, -4, eyeSize, eyeSize);
                ctx.restore();
            }
        }

        class Food {
            constructor() {
                this.lane = Math.floor(Math.random() * config.laneCount);
                this.angle = config.playerAngle - Math.PI + (Math.random() - 0.5);
                this.active = true;
                this.sprite = fruitSprites[this.lane];
            }
            update() {
                this.angle += config.rotationSpeed;
                let diff = Math.abs(this.angle - config.playerAngle);
                while(diff > Math.PI * 2) diff -= Math.PI * 2;
                
                if (diff < 0.12 && this.active) {
                    if (this.lane === state.currentLane) {
                        state.score += 100;
                        scoreEl.innerText = state.score.toString().padStart(5, '0');
                        this.active = false;
                        playScoreSound();
                        vibratePhone(10);
                    }
                }
                if (this.angle > config.playerAngle + 0.6) { this.active = false; }
            }
            draw() {
                if (!this.active) return;
                const r = config.baseRadius + (this.lane + 0.5) * config.laneGap;
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const x = cx + Math.cos(this.angle) * r;
                const y = cy + Math.sin(this.angle) * r;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.angle + Math.PI/2);
                ctx.drawImage(this.sprite, -this.sprite.width/2, -this.sprite.height/2);
                ctx.restore();
            }
        }

        const player = new Player();

        function updateUI() {
            const currentSong = config.dishNames[state.currentLane];
            if (subtitleEl.innerText !== currentSong) {
                subtitleEl.innerText = currentSong;
                subtitleEl.style.transform = 'skew(-10deg) scale(1.1)';
                setTimeout(() => {
                    subtitleEl.style.transform = 'skew(-10deg) scale(1)';
                }, 100);
            }
        }

        function createRipple(x, y) {
            state.ripples.push({x: x, y: y, radius: 10, alpha: 1});
        }

        function handleInput(e) {
            if(!state.isPlaying) return;
            
            let x = 0, y = 0;
            // 兼容鼠标和触摸坐标
            if(e.type === 'touchstart' && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else if (e.type === 'mousedown') {
                x = e.clientX;
                y = e.clientY;
            }
            createRipple(x, y);

            state.currentLane++;
            if (state.currentLane >= config.laneCount) { state.currentLane = 0; }
            updateUI();
            
            vibratePhone(30);

            if(audioCtx && audioCtx.state === 'running') {
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                 gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                 gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                 osc.connect(gain);
                 gain.connect(analyser); 
                 osc.start();
                 osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        startScreen.addEventListener('click', () => {
            state.isPlaying = true;
            startScreen.style.display = 'none';
            initAudio(); 
            updateUI();
            // 电脑上一般不需要全屏，但如果支持也可以触发
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {});
            }
        });
        
        // 绑定两个事件：触摸和鼠标
        window.addEventListener('touchstart', (e) => { 
            if(state.isPlaying) { 
                handleInput(e); 
            }
        }, {passive: false});
        
        window.addEventListener('mousedown', (e) => { 
            if(state.isPlaying) handleInput(e); 
        });

        function drawBackground() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            state.bgRotation += config.rotationSpeed * 0.1;

            ctx.save();
            ctx.translate(cx, cy);
            
            for(let i = config.laneCount - 1; i >= 0; i--) {
                const outerRadius = config.baseRadius + (i + 1) * config.laneGap;
                const innerRadius = config.baseRadius + i * config.laneGap;
                
                ctx.beginPath();
                ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                ctx.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
                
                if (i === state.currentLane) {
                    ctx.fillStyle = config.colors[i] + '55'; 
                } else {
                    ctx.fillStyle = config.colors[i] + '22'; 
                }
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(0, 0, (outerRadius + innerRadius) / 2, 0, Math.PI * 2);
                ctx.strokeStyle = config.colors[i] + '66';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            const centerRadius = config.baseRadius;
            ctx.beginPath();
            ctx.arc(0, 0, centerRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.restore();
            
            ctx.save();
            ctx.font = '14px "Courier New", monospace'; 
            ctx.textAlign = 'left';
            
            config.dishNames.forEach((name, i) => {
                const yPos = cy - 80 + (i * 35);
                const xPos = cx + centerRadius * 2.2; 
                
                if (i === state.currentLane) {
                    ctx.fillStyle = config.colors[i];
                    ctx.font = 'bold 15px "Courier New", monospace';
                    ctx.fillText("> " + name, xPos, yPos);
                    ctx.drawImage(fruitSprites[i], xPos - 30, yPos - 12);
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.font = '14px "Courier New", monospace';
                    ctx.fillText(name, xPos, yPos);
                }
            });
            ctx.restore();
        }

        function drawVisualizer() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            
            const barWidth = 12; 
            const gap = 4;
            const dataCount = 24; 
            const totalWidth = dataCount * (barWidth + gap);
            const startX = (canvas.width - totalWidth) / 2;
            
            ctx.save();
            ctx.fillStyle = 'rgba(77, 143, 255, 0.5)';
            
            for (let i = 0; i < dataCount; i++) {
                const value = dataArray[i + 2] || 0; 
                const percent = value / 255;
                const height = percent * 80 + 5; 
                
                const x = startX + i * (barWidth + gap);
                const y = canvas.height - height; 
                
                ctx.fillStyle = 'rgba(77, 143, 255, 0.6)';
                ctx.fillRect(x, y, barWidth, height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(x, y, barWidth, 3);
            }
            ctx.restore();
        }

        function drawRipples() {
            ctx.save();
            ctx.lineWidth = 2;
            for (let i = state.ripples.length - 1; i >= 0; i--) {
                const r = state.ripples[i];
                r.radius += 5;
                r.alpha -= 0.05;
                
                if (r.alpha <= 0) {
                    state.ripples.splice(i, 1);
                } else {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${r.alpha})`;
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function applyScreenGlitch() {
            if (Math.random() < 0.02) {
                const glitchHeight = Math.random() * 120 + 20;
                const glitchY = Math.random() * canvas.height;
                const glitchOffset = (Math.random() - 0.5) * 60;
                ctx.drawImage(canvas, 0, glitchY, canvas.width, glitchHeight, glitchOffset, glitchY, canvas.width, glitchHeight);
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                if (Math.random() > 0.5) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.fillRect(glitchOffset, glitchY, canvas.width, glitchHeight);
                } else {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.fillRect(-glitchOffset, glitchY, canvas.width, glitchHeight);
                }
                ctx.restore();
            }
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            if (state.isPlaying) {
                if (state.gameTime % 50 === 0) { state.foods.push(new Food()); }
                for (let i = state.foods.length - 1; i >= 0; i--) {
                    state.foods[i].update();
                    state.foods[i].draw();
                    if (!state.foods[i].active) { state.foods.splice(i, 1); }
                }
                state.gameTime++;
                drawVisualizer();
                drawRipples(); 
            }
            player.draw();
            if (state.isPlaying) { applyScreenGlitch(); }
            requestAnimationFrame(loop);
        }

        loop();

    </script>
</body>
</html>